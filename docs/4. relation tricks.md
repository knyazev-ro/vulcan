# Relation Tricks

Раздел посвящен практическим приемам и архитектурным возможностям Vulcan, которые делают работу с данными предсказуемой и эффективной.

---

## 1. Частичные DTO для отношений

Отношения в Vulcan не обязаны быть полными копиями таблиц. Вы можете описывать минимально необходимые поля для связанных сущностей.

```go
type CityShort struct {
    _    string `type:"metadata" table:"report_cities" pk:"id"`
    Id   int64  `type:"column" col:"id"`
    City string `type:"column" col:"city"`
}

type Report struct {
    _    string    `type:"metadata" table:"reports" pk:"id"`
    Id   int64     `type:"column" col:"id"`
    City CityShort `type:"relation" table:"report_cities" reltype:"belongs-to" fk:"city_id"`
}

```

**Результат:** SQL-запрос будет содержать только `id` и `city`, исключая загрузку тяжелых или ненужных полей из связанных таблиц.

---

## 2. Изолированная фильтрация (`With`)

Метод `With` позволяет накладывать условия **только на само отношение**, не модифицируя основной запрос к родительской таблице.

```go
report, _, _ := vulcan.NewQuery[ReportData]().
    With("City", func(q *vulcan.Query[ReportData]) {
        q.Where("city", "like", "Москва")
    }).
    FindById(ctx, 2)

```

* Основная запись загрузится в любом случае.
* Если условие `With` не выполнено, поле отношения останется пустым, но родительский объект не будет отфильтрован.

---

## 3. Глубокая вложенная фильтрация

Vulcan позволяет рекурсивно настраивать фильтры для любого уровня вложенности графа.

```go
users, _ := vulcan.NewQuery[User]().
    With("Posts", func(q *vulcan.Query[User]) {
        q.Where("published", "=", 1).
        With("Comments", func(q *vulcan.Query[User]) {
            q.Where("approved", "=", 1)
        })
    }).
    CLoad(ctx)

```

---

## 4. Отношения как агрегации

Отношение может представлять собой не просто запись, а результат агрегации данных.

```go
type PostCount struct {
    _     string `type:"metadata" table:"posts"`
    Count int64  `type:"column" col:"*" agg:"count"`
}

type User struct {
    _          string    `type:"metadata" table:"users" pk:"id"`
    Id         int64     `type:"column" col:"id"`
    PostsCount PostCount `type:"relation" table:"posts" reltype:"has-one" fk:"user_id"`
}

```

Это позволяет получить, например, количество постов пользователя без написания `GROUP BY` или ручного SQL.

---

## 5. Архитектурная стратегия: Отношения ≠ JOIN

Vulcan сознательно избегает построения гигантских JOIN-запросов для загрузки отношений.

**Почему это важно:**

* **Кардинальность:** Избегается "взрыв" количества строк в результате запроса при множественных `has-many`.
* **Индексы:** Простые запросы по первичным ключам для отношений работают быстрее и эффективнее используют кэш БД.
* **Гидратация:** Сборка объекта из плоского набора данных с дубликатами (как после JOIN) на порядки дороже, чем маппинг чистых выборок.

**Как это работает:** Vulcan делает основной запрос, затем собирает ключи и выполняет оптимизированные дополнительные запросы для отношений, связывая их в памяти.

---

## 6. Гибкое управление контрактами

Вы можете полностью изменить состав загружаемых данных, просто подменив DTO.

* **UserFull** — для страницы профиля (все связи).
* **UserIndex** — для списка (только основные поля).
* **UserAuth** — только `id`, `login` и `password_hash`.

Ваш код всегда получает ровно ту форму результата, которую вы определили типом данных.