Для документации в стиле Laravel я сгруппировал методы по их назначению: от построения условий до выполнения запросов и работы с мутациями.

# API Reference: Query Builder & ORM

Ниже представлен полный список доступных методов Vulcan для работы с данными.

---

## Построение условий (Where Clauses)

| Метод | Описание |
| --- | --- |
| `Where(col, op, val)` | Добавляет базовое условие `AND`. |
| `OrWhere(col, op, val)` | Добавляет условие через `OR`. |
| `WhereClause(func)` | Группирует условия в скобки `(...)`. |
| `OrWhereClause(func)` | Группирует условия в скобки через `OR (...)`. |

---

## Связи и объединения (Joins & Relations)

| Метод | Описание |
| --- | --- |
| `With(relation, func)` | Фильтрует подгружаемое отношение без влияния на основной запрос. |
| `InnerJoin(table, func)` | Выполняет `INNER JOIN`. Внутри замыкания используется `On()`. |
| `LeftJoin(table, func)` | Выполняет `LEFT JOIN`. |
| `On(col1, op, col2)` | Используется внутри джоинов или `From()` для связки таблиц. |
| `From(tables...)` | Указывает дополнительные таблицы (актуально для сложных `UPDATE`). |

---

## Результаты и выполнение (Execution)

| Метод | Описание |
| --- | --- |
| `Load(ctx)` | Выполняет запрос и возвращает слайс структур (синхронно). |
| `CLoad(ctx)` | **Concurrent Load**: конкурентная загрузка графа отношений через горутины. |
| `FindById(ctx, ...ids)` | Ищет запись по первичному ключу. Если в metadata указано несколько pk, количество аргументов должно строго совпадать. Возвращает `(struct, bool, error)`. |
| `Create(ctx, map)` | Вставляет новую запись в базу. |
| `Update(ctx, map)` | Обновляет записи, соответствующие условиям Builder. |
| `Delete(ctx)` | Удаляет записи, соответствующие условиям. |

---

## Формирование SQL и Опции

| Метод | Описание |
| --- | --- |
| `Build()` | Инициирует сборку SQL-запроса на основе структуры и условий. |
| `SQL()` | Возвращает строковое представление собранного запроса. |
| `OrderBy(direction, cols...)` | Задает направление сортировки (`asc` или `desc`). |
| `Limit(n)` | Ограничивает количество возвращаемых записей. |
| `Offset(n)` | Пропускает указанное количество строк. |
| `UseConn(tx/db)` | Указывает конкретное соединение или транзакцию для выполнения. |

---

## Системные и глобальные методы

| Метод | Описание |
| --- | --- |
| `NewQuery[T]()` | Создает новый экземпляр Builder для указанного типа `T`. |
| `Transaction(ctx, func)` | Обертка для выполнения группы запросов внутри одной транзакции. |

### Визуальная иерархия вызова

```go
// Стандартная цепочка вызова
result, err := vulcan.NewQuery[User](). // 1. Инициализация
    Where("active", "=", 1).            // 2. Построение (Builder)
    OrderBy("desc", "id").              // 3. Сортировка
    CLoad(ctx)                          // 4. Выполнение (Execution)

```

---

# Структурные теги (Tags Reference)

Vulcan использует систему тегов для маппинга структур Go на таблицы SQL и описания графа связей. Все метаданные считываются через рефлексию в рантайме.

---

## 1. Метаданные таблицы (`type:"metadata"`)

Это обязательное техническое поле (именуемое как `_`), которое определяет базовые параметры таблицы.

| Параметр | Описание | Пример |
| --- | --- | --- |
| `table` | Имя таблицы в БД.                                       | `table:"users"` |
| `pk` | Первичный ключ                                             | `pk:"id"` |
| `tabletype` | (Опционально) Указывает на специальный тип таблицы. | `tabletype:"pivot"` |

```go
_ string `type:"metadata" table:"posts" pk:"id"`

```

---

## 2. Колонки (`type:"column"`)

Описывают обычные поля данных, которые будут включены в `SELECT`.

| Параметр | Описание | Пример |
| --- | --- | --- |
| `col` | Имя колонки в таблице. | `col:"user_id"` |
| `agg` | (Опционально) Функция агрегации: **max, count, avg, sum, min**. | `agg:"count"` |

> **Поддержка NULL:** Если поле может содержать NULL, используйте указатель (например, `*string`, `*int64`).

---

## 3. Отношения (`type:"relation"`)

Связывают текущую структуру с другими таблицами.

| Параметр | Описание | Пример |
| --- | --- | --- |
| `reltype` | Тип связи: **belongs-to, has-one, has-many**. | `reltype:"has-many"` |
| `table` | Таблица, к которой мы обращаемся. | `table:"profiles"` |
| `fk` | Foreign Key (Внешний ключ) для связи. | `fk:"user_id"` |
| `originalkey` | Ключ в текущей или целевой таблице для сопоставления. | `originalkey:"id"` |

---

## Примеры реализации

### Many-to-Many через Pivot

Для реализации связи «многие-ко-многим» создается промежуточная структура с тегом `tabletype:"pivot"`.

```go
type PostTag struct {
    _      string  `type:"metadata" table:"post_tags" pk:"post_id,tag_id" tabletype:"pivot"`
    PostId int64   `type:"column" col:"post_id"`
    TagId  int64   `type:"column" col:"tag_id"`
    // Связь внутри пивота указывает на конечную сущность
    Tag    TagTest `type:"relation" table:"tags" reltype:"belongs-to" fk:"tag_id" originalkey:"id"`
}

```

### Сложная иерархия (User -> Posts -> Tags)

```go
type UserTest struct {
    _       string      `type:"metadata" table:"users" pk:"id"`
    Id      int64       `type:"column" col:"id"`
    // Has-Many: вернет слайс постов
    Posts   []PostTest  `type:"relation" table:"posts" reltype:"has-many" fk:"user_id" originalkey:"id"`
    // Has-One: вернет одну структуру профиля
    Profile ProfileTest `type:"relation" table:"profiles" reltype:"has-one" fk:"user_id" originalkey:"id"`
}

```