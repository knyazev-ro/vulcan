# Query Builder

Query Builder в Vulcan — это низкоуровневый, но выразительный инструмент для построения SQL-запросов.
Он не привязан к глобальным моделям и работает с **контекстными DTO-структурами**.

Ниже приведены примеры основных возможностей.

---

## Базовая модель

```go
type UserTest struct {
	_        string `type:"metadata" table:"users" pk:"id"`
	Id       int64  `type:"column" col:"id"`
	Name     string `type:"column" col:"name"`
	LastName string `type:"column" col:"last_name"`
}
```

---

## Load / CLoad

### Загрузка всех записей

```go
ctx := context.Background()

users, err := vulcan.NewQuery[UserTest]().CLoad(ctx)
if err != nil {
	fmt.Println("Load error:", err)
}
fmt.Println("Loaded:", len(users))
```

`CLoad()` выполняет конкурентную загрузку данных с использованием goroutines.

---

## Where / OrWhere

```go
users, err := vulcan.NewQuery[UserTest]().
	Where("id", ">", 1).
	Where("id", "!=", 3).
	CLoad(ctx)
```

```go
sql := vulcan.NewQuery[UserTest]().
	Where("role", "=", "admin").
	OrWhere("role", "=", "moderator").
	Build().
	SQL()
```

---

## Вложенные условия (WhereClause)

```go
q := vulcan.NewQuery[UserTest]().
	Where("active", "=", 1).
	WhereClause(func(q *vulcan.Query[UserTest]) {
		q.Where("role", "=", "admin").
			OrWhereClause(func(q *vulcan.Query[UserTest]) {
				q.Where("role", "=", "moderator").
					Where("age", ">", 30)
			})
	})
```

---

## Join’ы

```go
q := vulcan.NewQuery[UserTest]().
	InnerJoin("posts", func(jc *vulcan.Join) {
		jc.On("posts.user_id", "=", "users.id")
	}).
	LeftJoin("categories", func(jc *vulcan.Join) {
		jc.On("categories.id", "=", "posts.category_id")
	})
```

---

## Order / Limit / Offset

```go
q := vulcan.NewQuery[UserTest]().
	OrderBy([]string{"id"}, "desc").
	Limit(50).
	Offset(10)
```

---

## Update с JOIN

```go
err := vulcan.NewQuery[UserTest]().
	From("posts").
	On("posts.id", "=", "users.post_id").
	Where("users.id", "=", 10).
	Update(ctx, map[string]any{
		"users.role_id": 1,
	})
```

---

## Получение SQL

```go
sql := vulcan.NewQuery[UserTest]().
	Where("name", "like", "%A%").
	Build().
	SQL()

fmt.Println(sql)
```

---

# ORM

ORM-слой Vulcan работает поверх Query Builder и добавляет:

* автоматическую загрузку отношений
* поддержку `has-one`, `has-many`, `belongs-to`
* pivot-таблицы
* агрегаты
* конкурентную загрузку графа данных

---

## Отношения

```go
type PostTest struct {
	_        string `type:"metadata" table:"posts" pk:"id"`
	Id       int64  `type:"column" col:"id"`
	Name     string `type:"column" col:"name"`
	UserId   int64  `type:"column" col:"user_id"`
}

type ProfileTest struct {
	_      string `type:"metadata" table:"profiles" pk:"id"`
	Id     int64  `type:"column" col:"id"`
	UserId int64  `type:"column" col:"user_id"`
	Bio    string `type:"column" col:"bio"`
}

type UserTest struct {
	_       string        `type:"metadata" table:"users" pk:"id"`
	Id      int64         `type:"column" col:"id"`
	Name    string        `type:"column" col:"name"`
	Posts   []PostTest   `type:"relation" table:"posts" reltype:"has-many" fk:"user_id"`
	Profile ProfileTest  `type:"relation" table:"profiles" reltype:"has-one" fk:"user_id"`
}
```

---

## Load с отношениями

```go
users, err := vulcan.NewQuery[UserTest]().CLoad(ctx)
```

---

## With — фильтрация отношений

```go
user, ok, err := vulcan.NewQuery[UserTest]().
	With("Posts", func(q *vulcan.Query[UserTest]) {
		q.Where("published", "=", 1)
	}).
	FindById(ctx, 3)
```

---

## Pivot-таблицы (many-to-many)

```go
type TagTest struct {
	_    string `type:"metadata" table:"tags" pk:"id"`
	Id   int64  `type:"column" col:"id"`
	Name string `type:"column" col:"name"`
}

type PostTag struct {
	_      string  `type:"metadata" table:"post_tags" pk:"post_id,tag_id" tabletype:"pivot"`
	PostId int64   `type:"column" col:"post_id"`
	TagId  int64   `type:"column" col:"tag_id"`
	Tag    TagTest `type:"relation" table:"tags" reltype:"belongs-to" fk:"tag_id"`
}
```

---

## Create / Update / Delete

```go
vulcan.NewQuery[UserTest]().Create(ctx, map[string]any{
	"name": "John",
})
```

```go
vulcan.NewQuery[UserTest]().
	Where("id", "=", 1).
	Update(ctx, map[string]any{
		"name": "Jack",
	})
```

```go
vulcan.NewQuery[UserTest]().
	Where("id", "=", 1).
	Delete(ctx)
```

---

## Транзакции

```go
vulcan.Transaction(ctx, func(tx *sql.Tx) error {
	query, err := vulcan.NewQuery[UserTest]().UseConn(tx)
	if err != nil {
		return err
	}
	_, err = query.Load(ctx)
	return err
})
```

---

## Итог

* Query Builder — для точного и сложного SQL
* ORM — для работы с графом данных
* DTO-структуры — контракт между кодом и БД
* Конкурентная загрузка — встроена
* Over-fetching исключён по дизайну