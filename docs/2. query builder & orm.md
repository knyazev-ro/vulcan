# Query Builder

**Query Builder** в Vulcan — это низкоуровневый инструмент для построения SQL-запросов, работающий с контекстными DTO-структурами.

## Выборка данных (Load)

### Простой запрос

```go
ctx := context.Background()

// CLoad использует конкурентную загрузку через горутины
users, err := vulcan.NewQuery[UserTest]().CLoad(ctx)

```

### Фильтрация (Where / OrWhere)

```go
// AND условия
users, err := vulcan.NewQuery[UserTest]().
    Where("id", ">", 1).
    Where("id", "!=", 3).
    CLoad(ctx)

// OR условия
sql := vulcan.NewQuery[UserTest]().
    Where("role", "=", "admin").
    OrWhere("role", "=", "moderator").
    Build().SQL()

```

### Вложенные условия (Groups)

```go
q := vulcan.NewQuery[UserTest]().
    Where("active", "=", 1).
    WhereClause(func(q *vulcan.Query[UserTest]) {
        q.Where("role", "=", "admin").
            OrWhereClause(func(q *vulcan.Query[UserTest]) {
                q.Where("role", "=", "moderator").
                Where("age", ">", 30)
            })
    })

```

## Связи и Джоины

### SQL Joins

```go
q := vulcan.NewQuery[UserTest]().
    InnerJoin("posts", func(jc *vulcan.Join) {
        jc.On("posts.user_id", "=", "users.id")
    }).
    LeftJoin("categories", func(jc *vulcan.Join) {
        jc.On("categories.id", "=", "posts.category_id")
    })

```

### Сортировка и Лимиты

```go
q := vulcan.NewQuery[UserTest]().
    OrderBy("desc", "id").
    Limit(50).
    Offset(10)

```

## Пагинация

### Клаасическая пагинация с использованием OFFSET

Vulcan предлагает полный контроль над пагинацией, исключая, либо минимизируя магию. Классическая пагинация реализовывает под капотом последовательное применение `OrderBy`, `Offset` и `Limit`.

**Если в построении запроса уже участвовал `OrderBy`, сортировка по умолчанию не будет применена.**  

```go
sql := vulcan.NewQuery[UserTest]().Paginate("id", 1, 10).Build().SQL()
sql := vulcan.NewQuery[UserTest]().Paginate("id", 2, 10).Build().SQL()
sql := vulcan.NewQuery[UserTest]().Paginate("id", 3, 10).Build().SQL()
```

### Курсорная пагинация

Vulcan поддерживает курсорную пагинацию, когда процесс загрузки следующей страницы отталкивается от последней записи с предыдущей страницы в предварительно отсортированных данных. По-умолчанию, метод `CursorPaginate` отсортирует данные в порядке возрастания по колонке, относительно которой будет произведена пагинация. 

**Если в построении запроса уже участвовал `OrderBy`, сортировка по умолчанию не будет применена.**  

```go
// При загрузке первой страницы. Предполагаем, что фронтенд запомнил id последней записи в массиве данных, что пришли к нему с первой страницей.
sql := vulcan.NewQuery[UserTest]().CursorPaginate("id", nil, 10).Build().SQL() // PAGE 1
// Допустим, последняя запись в первом листе имела id = 24, тогда:
sql := vulcan.NewQuery[UserTest]().CursorPaginate("id", 24, 10).Build().SQL() // PAGE 2
// Допустим, на втором листе в последней записи id = 36
sql := vulcan.NewQuery[UserTest]().CursorPaginate("id", 36, 10).Build().SQL() // PAGE 3
// И так далее...
```

Для web-приложений вы можете спокойно написать оболочку для Paginate и CursorPaginate библиотеки Vulcan, чтобы получать пагинированные данные.


---

# ORM и Отношения

ORM Vulcan автоматически загружает граф данных, основываясь на тегах структуры.

## Описание отношений

```go
type UserTest struct {
    _       string       `type:"metadata" table:"users" pk:"id"`
    Id      int64        `type:"column" col:"id"`
    Name    string       `type:"column" col:"name"`
    // Relations
    Posts   []PostTest   `type:"relation" table:"posts" reltype:"has-many" fk:"user_id"`
    Profile ProfileTest  `type:"relation" table:"profiles" reltype:"has-one" fk:"user_id"`
}

```

## Eager Loading и фильтрация

```go
// Загрузка пользователя и только опубликованных постов
user, ok, err := vulcan.NewQuery[UserTest]().
    With("Posts", func(q *vulcan.Query[UserTest]) {
        q.Where("published", "=", 1)
    }).
    FindById(ctx, 3)

```

## Pivot-таблицы (Many-to-Many)

```go
type PostTag struct {
    _      string  `type:"metadata" table:"post_tags" pk:"post_id,tag_id" tabletype:"pivot"`
    PostId int64   `type:"column" col:"post_id"`
    TagId  int64   `type:"column" col:"tag_id"`
    Tag    TagTest `type:"relation" table:"tags" reltype:"belongs-to" fk:"tag_id"`
}

```

---

# Мутации и Транзакции

## CRUD операции

```go
// Create
vulcan.NewQuery[UserTest]().Create(ctx, map[string]any{"name": "John"})

// Update с фильтрацией
vulcan.NewQuery[UserTest]().Where("id", "=", 1).Update(ctx, map[string]any{"name": "Jack"})

// Delete
vulcan.NewQuery[UserTest]().Where("id", "=", 1).Delete(ctx)

```

## Транзакции

```go
vulcan.Transaction(ctx, func(tx *sql.Tx) error {
    query, err := vulcan.NewQuery[UserTest]().UseConn(tx)
    if err != nil {
        return err
    }
    _, err = query.Load(ctx)
    return err
})

```

## Плоская JOIN-структура

На самом деле, вы можете спокойно получать и плоские записи от JOIN объединений. Просто думайте о структурах, как о схеме для SELECT, где **все**, что помечено, как `column` становится частью SELECT. Чтобы в одной структуре отобразить то, что стало результатом JOIN, вам достаточно указать из какой таблицы будет текущая колонка через тег `table`.

```go
type UserTest struct {
    _       string       `type:"metadata" table:"users" pk:"id"`
    Id      int64        `type:"column" col:"id"`
    Name    string       `type:"column" col:"name"`
    // Relations
    Bio     *string  `type:"column" col"bio" table:"profiles"`
}
	vulcan.NewQuery[UserTest]().LeftJoin("profiles", func(jc *vulcan.Join) { jc.On("profiles.user_id", "=", "users.id") }).Load(ctx)
```
