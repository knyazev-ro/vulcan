## Vulcan ORM: Data Mapper for Go

**Vulcan** — это высокопроизводительный ORM с выразительным **Query Builder**, вдохновленный синтаксисом **Laravel Eloquent**, но реализованный через паттерн **Data Mapper**.

### Ключевое отличие

В отличие от Active Record, где модель «знает» о базе данных, в Vulcan модели — это **чистые структуры (DTO)**. Отношения описываются декларативно через теги полей.

---

## Описание моделей

Модели в Vulcan контекстуальны. Вы описываете только те поля, которые нужны в конкретном месте программы.

```go
type ReportCity struct {
    _        string   `type:"metadata" table:"report_cities" pk:"id"`
    Id       int64    `type:"column" col:"id"`
    ReportId int64    `type:"column" col:"report_id"`
    City     string   `type:"column" col:"city"`
    Code     *string  `type:"column" col:"code"` // Поддержка NULL через указатель
    Report   Report   `type:"relation" table:"reports" reltype:"belongs-to" fk:"report_id" originalkey:"id"`
}

```

> **Важно:** Vulcan генерирует SQL-запрос только для тех колонок, которые описаны в структуре. Это исключает проблему **over-fetching** на уровне дизайна.

---

## Почему Vulcan?

### 1. Zero Over-fetching

В большинстве ORM запрос `db.Find(&user)` делает `SELECT *`. В Vulcan **структура — это проекция**.

* Описали 2 поля — получили `SELECT col1, col2`.
* Не нужно вручную вызывать `.Select()`.

### 2. Производительность (Concurrency-first)

Библиотека спроектирована под многопоточность Go:
| Фича | Описание |
| :--- | :--- |
| **CLoad** | Рекурсивная подгрузка связей (`HasMany`, `BelongsTo`) в параллельных горутинах. |
| **Smart Hydration** | Минимизация аллокаций при сборке сложных деревьев объектов. |
| **Built-in Semaphore** | Ограничение нагрузки на БД на уровне движка ORM. |

### 3. Connection Management

Полный контроль над пулом соединений для работы под экстремальной нагрузкой:

* Настройка `MaxOpenConns` и `MaxIdleConns`.
* Управление `ConnMaxLifetime` для стабильности сетевых сессий.

---

## Примеры использования

### Поиск по ID с вложенными связями

```go
ctx := context.Background()
user, ok, err := vulcan.NewQuery[UserTest]().FindById(ctx, 3)

```

### Сложный Update с фильтрацией через Join

```go
	err := vulcan.NewQuery[UserTest]().
		From("posts", "tags").
		On("posts.user_id", "=", "users.id"). // Связь User -> Posts
		Where("users.id", "=", 3).
		Where("posts.name", "=", "Zachary Terminals: Budget Edition").
		LeftJoin("tags", func(jc *vulcan.Join) {
			jc.On("tags.id", "=", "posts.id") // Пример джоина для фильтрации
		}).
		Where("tags.name", "like", "Hardware").
		Update(ctx, map[string]any{
			"name":      "Deadman",
			"last_name": "Surree",
		})
	if err != nil {
		fmt.Println("Difficult update error: ", err.Error())
	}

```