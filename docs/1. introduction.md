## Введение

**Vulcan** — это ORM с полноценным **Query Builder**, ориентированный на быструю и предсказуемую разработку.
Идея библиотеки вдохновлена **Eloquent ORM** из фреймворка **Laravel**.

Vulcan стремится быть максимально близким к Eloquent с точки зрения **синтаксиса и выразительности Query Builder**, но при этом использует **принципиально противоположный архитектурный подход**.

Вместо паттерна **Active Record** в Vulcan реализован **Data Mapper**.
Отношения между сущностями описываются **как поля структуры**, а не как методы класса.

---

## Философия

Философия Vulcan исключает использование громоздких глобальных сущностей и «всезнающих» моделей.

Данные описываются **контекстуально** - ровно там, где они используются:

* в репозитории,
* в контроллере,
* в бизнес-логике.

Относитесь к моделям Vulcan как к **Data Transfer Object (DTO)**, а не как к полноценным доменным моделям.

Хотя такие структуры могут содержать связи (`belongsTo`, `hasMany` и т.д.), по своей сути они остаются **переносчиками данных**, а не объектами с поведением.

---

## Описание моделей

Ниже приведён пример модели Vulcan:

```go
type ReportCity struct {
    _        string          `type:"metadata" table:"report_cities" pk:"id"`
    Id       int64           `type:"column" col:"id"`
    ReportId int64           `type:"column" col:"report_id"`
    City     string          `type:"column" col:"city"`
    Order    int64           `type:"column" col:"order"`
    Code     *string         `type:"column" col:"code"` // NULL field support via pointer
	Report   Report          `type:"relation" table:"reports" reltype:"belongs-to" fk:"report_id" originalkey:"id"`

}
```

### Важно

Модели Vulcan **НЕ являются абсолютным представлением таблицы** в базе данных.

Они могут быть:

* частичными,
* полными,
* специализированными под конкретный запрос.

Такой подход избавляет от проблемы **over-fetching** - база данных возвращает **ровно тот набор данных, который описан в структуре**.

---

## Частичные модели (DTO-first)

В рамках одного проекта вы можете обращаться к одной и той же таблице, описывая разные структуры под разные задачи.

Например, получить только `id` и `city`:

```go
type ReportCityOnlyName struct {
    _    string `type:"metadata" table:"report_cities" pk:"id"`
    Id   int64  `type:"column" col:"id"`
    City string `type:"column" col:"city"`
}
```

В этом случае:

* запрос к БД будет сформирован **только по этим полям**,
* лишние данные не будут загружены,
* структура становится **контрактом результата**.

---

## Контракт данных

В Vulcan **структура определяет запрос**.

Если в структуре указаны только поля `id` и `city`, то:

* именно эти поля будут запрошены,
* именно такая структура данных будет возвращена.

Это даёт:

* предсказуемость,
* прозрачность,
* простоту сопровождения.

Вы знаете, **как будут выглядеть данные на выходе**, ещё до выполнения запроса, просто описав структуру.

## Почему Vulcan?

Большинство ORM для Go либо пытаются копировать паттерны из объектно-ориентированных языков (Active Record), либо заставляют вас писать SQL вручную. Vulcan выбирает третий путь: **Go-native Data Mapping**.

### 1. Структура как Контракт (Zero Over-fetching)

В традиционных ORM (например, GORM) запрос `db.Find(&user)` всегда генерирует `SELECT *`, даже если в вашей структуре всего два поля. Это тратит память, ресурсы сети и нагружает БД.

В Vulcan **ваша структура и есть SQL-проекция**. Если вы описали в DTO три поля - Vulcan запросит из базы ровно три поля. Больше никакого ручного `.Select("id", "name")` и дублирования строк.

### 2. Производительность «из коробки»

Vulcan вдохновлен простотой Laravel Eloquent, но построен на принципах высокой производительности Go:

* **CLoad (Concurrent Load):** Рекурсивная подгрузка отношений (BelongsTo, HasMany) происходит параллельно в горутинах.
* **Smart Hydration:** Умное маппинг-дерево, которое собирает миллионы объектов за секунды, минимизируя аллокации памяти.
* **Built-in Semaphore:** Встроенный контроль конкурентности защищает вашу базу от сильной нагрузки, ограничивая количество одновременных запросов на уровне движка.

### 3. Чистая архитектура без глобальных зависимостей

Vulcan не заставляет вас наследовать «базовые модели» или регистрировать глобальные сущности.

* Модели — это просто **DTO**.
* Вы можете определять разные представления одной и той же таблицы для разных задач (например, `UserBrief` для списка и `UserFull` для профиля).
* Идеально подходит для реализации паттерна **Repository**.

### 4. Продвинутый Connection Pool Management

Vulcan дает полный контроль над жизненным циклом соединений. Вы можете тонко настроить:

* `MaxIdleConns` и `MaxOpenConns` для удержания «горячих» соединений.
* `ConnMaxLifetime` и `ConnMaxIdleTime` для предотвращения деградации сети.
Это делает Vulcan готовым к экстремальным нагрузкам.

---
*Цель Vulcan - дать предсказуемость SQL и скорость Go, сохраняя при этом удобство Eloquent.*