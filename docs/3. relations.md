# Relations

В Vulcan отношения описываются декларативно через теги в структурах. Это исключает неявное поведение и обеспечивает предсказуемость запросов.

---

## Поддерживаемые типы

### 1. belongs-to

Текущая сущность содержит внешний ключ (FK) и ссылается на родителя.

```go
type Post struct {
    _          string   `type:"metadata" table:"posts" pk:"id"`
    CategoryId int64    `type:"column" col:"category_id"`
    Category   Category `type:"relation" table:"categories" reltype:"belongs-to" fk:"category_id" originalkey:"id"`
}

```

### 2. has-one

Связь «один к одному». Дочерняя запись ссылается на текущую.

```go
type User struct {
    _       string  `type:"metadata" table:"users" pk:"id"`
    Id      int64   `type:"column" col:"id"`
    Profile Profile `type:"relation" table:"profiles" reltype:"has-one" fk:"user_id" originalkey:"id"`
}

```

### 3. has-many

Связь «один ко многим». Возвращает слайс структур.

```go
type User struct {
    _     string `type:"metadata" table:"users" pk:"id"`
    Id    int64  `type:"column" col:"id"`
    Posts []Post `type:"relation" table:"posts" reltype:"has-many" fk:"user_id" originalkey:"id"`
}

```

### 4. many-to-many (pivot)

Реализуется через промежуточную DTO-модель с тегом `tabletype:"pivot"`.

```go
type PostTag struct {
    _      string  `type:"metadata" table:"post_tags" pk:"post_id,tag_id" tabletype:"pivot"`
    PostId int64   `type:"column" col:"post_id"`
    TagId  int64   `type:"column" col:"tag_id"`
    Tag    Tag     `type:"relation" table:"tags" reltype:"belongs-to" fk:"tag_id" originalkey:"id"`
}

```

---

## Загрузка и фильтрация

### Методы загрузки

* **Load():** Последовательная синхронная загрузка графа.
* **CLoad():** Конкурентная загрузка отношений с использованием goroutines.

### Стейт-менеджмент отношений (With)

Метод `With` позволяет передать замыкание для фильтрации вложенных данных без изменения основного запроса.

```go
user, _, _ := vulcan.NewQuery[User]().
    With("Posts", func(q *vulcan.Query[User]) {
        q.Where("published", "=", 1)
    }).
    FindById(ctx, 1)

```

---

## Глубокие графы (Nested Relations)

Vulcan рекурсивно обходит структуру и подгружает все вложенные отношения, сколько бы уровней иерархии ни было описано в DTO.

```go
// Загрузит цепочку: User -> Posts -> Comments за один вызов
users, err := vulcan.NewQuery[User]().CLoad(ctx)

```

---

## Основные принципы Relations

1. **Явность:** Загружается только то, что описано в полях структуры.
2. **Отсутствие Lazy Loading:** Вы всегда знаете, когда данные запрашиваются из БД.
3. **Решение N+1:** Vulcan оптимизирует запросы к связанным таблицам, используя агрегированные выборки по ключам.
4. **Форма результата:** Структура DTO является финальным контрактом данных.
