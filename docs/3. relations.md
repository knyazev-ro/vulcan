# Relations

Vulcan поддерживает работу с отношениями на уровне **структур**, а не методов.
Отношения описываются декларативно и являются частью DTO-модели.

Поддерживаемые типы отношений:

* `belongs-to`
* `has-one`
* `has-many`
* `many-to-many` (через pivot-таблицы)

Отношения **не являются ленивыми** и загружаются явно через `Load / CLoad / With`.

---

## belongs-to

Используется, когда текущая сущность **ссылается на родительскую**.

```go
type Category struct {
	_    string `type:"metadata" table:"categories" pk:"id"`
	Id   int64  `type:"column" col:"id"`
	Name string `type:"column" col:"name"`
}

type Post struct {
	_          string   `type:"metadata" table:"posts" pk:"id"`
	Id         int64    `type:"column" col:"id"`
	Name       string   `type:"column" col:"name"`
	CategoryId int64    `type:"column" col:"category_id"`
	Category   Category `type:"relation" table:"categories" reltype:"belongs-to" fk:"category_id" originalkey:"id"`
}
```

---

## has-one

Используется для связи «один к одному», когда **дочерняя запись принадлежит родителю**.

```go
type Profile struct {
	_      string `type:"metadata" table:"profiles" pk:"id"`
	Id     int64  `type:"column" col:"id"`
	UserId int64  `type:"column" col:"user_id"`
	Bio    string `type:"column" col:"bio"`
}

type User struct {
	_       string  `type:"metadata" table:"users" pk:"id"`
	Id      int64   `type:"column" col:"id"`
	Name    string  `type:"column" col:"name"`
	Profile Profile `type:"relation" table:"profiles" reltype:"has-one" fk:"user_id" originalkey:"id"`
}
```

---

## has-many

Связь «один ко многим».

```go
type Post struct {
	_      string `type:"metadata" table:"posts" pk:"id"`
	Id     int64  `type:"column" col:"id"`
	UserId int64  `type:"column" col:"user_id"`
	Name   string `type:"column" col:"name"`
}

type User struct {
	_     string `type:"metadata" table:"users" pk:"id"`
	Id    int64  `type:"column" col:"id"`
	Name  string `type:"column" col:"name"`
	Posts []Post `type:"relation" table:"posts" reltype:"has-many" fk:"user_id" originalkey:"id"`
}
```

---

## many-to-many (pivot)

Для many-to-many используется **pivot-таблица**, описываемая как отдельная DTO-модель.

```go
type Tag struct {
	_    string `type:"metadata" table:"tags" pk:"id"`
	Id   int64  `type:"column" col:"id"`
	Name string `type:"column" col:"name"`
}

type PostTag struct {
	_      string `type:"metadata" table:"post_tags" pk:"post_id,tag_id" tabletype:"pivot"`
	PostId int64  `type:"column" col:"post_id"`
	TagId  int64  `type:"column" col:"tag_id"`
	Tag    Tag    `type:"relation" table:"tags" reltype:"belongs-to" fk:"tag_id" originalkey:"id"`
}

type Post struct {
	_        string    `type:"metadata" table:"posts" pk:"id"`
	Id       int64     `type:"column" col:"id"`
	Name     string    `type:"column" col:"name"`
	PostTags []PostTag `type:"relation" table:"post_tags" reltype:"has-many" fk:"post_id" originalkey:"id"`
}
```

---

## Загрузка отношений

```go
posts, err := vulcan.NewQuery[Post]().CLoad(ctx)
```

Все описанные отношения будут загружены автоматически.

---

## With — фильтрация отношений

`With` позволяет применять условия **только к отношению**, не затрагивая основной запрос.

```go
user, ok, err := vulcan.NewQuery[User]().
	With("Posts", func(q *vulcan.Query[User]) {
		q.Where("published", "=", 1)
	}).
	FindById(ctx, 1)
```

---

## Глубокие графы отношений

Vulcan поддерживает загрузку **многоуровневых графов**:

```go
type Comment struct {
	_      string `type:"metadata" table:"comments" pk:"id"`
	Id     int64  `type:"column" col:"id"`
	PostId int64  `type:"column" col:"post_id"`
	Text   string `type:"column" col:"text"`
}

type Post struct {
	_        string    `type:"metadata" table:"posts" pk:"id"`
	Id       int64     `type:"column" col:"id"`
	UserId   int64     `type:"column" col:"user_id"`
	Comments []Comment `type:"relation" table:"comments" reltype:"has-many" fk:"post_id"`
}

type User struct {
	_     string `type:"metadata" table:"users" pk:"id"`
	Id    int64  `type:"column" col:"id"`
	Name  string `type:"column" col:"name"`
	Posts []Post `type:"relation" table:"posts" reltype:"has-many" fk:"user_id"`
}
```

```go
users, err := vulcan.NewQuery[User]().CLoad(ctx)
```

---

## Конкурентная загрузка отношений

* `Load()` — последовательная загрузка (без goroutines)
* `CLoad()` — конкурентная загрузка отношений

```go
users, err := vulcan.NewQuery[User]().Load(ctx)   // sync
users, err := vulcan.NewQuery[User]().CLoad(ctx) // concurrent
```

---

## Важные принципы

* Отношения **явно описываются**
* Нет ленивых запросов
* Нет N+1
* Нет скрытых SQL
* Структура определяет форму результата
* Over-fetching исключён